import os
import json
import sys
import time
import requests
from typing import Dict, Any, Optional
from dataclasses import dataclass

# Try to load dotenv if available, otherwise rely on environment
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass

API_KEY = os.getenv("PANDADOC_API_KEY")
API_URL = "https://api.pandadoc.com/public/v1/documents"
TEMPLATE_UUID = "G8GhAvKGa9D8dmpwTnEWyV"

@dataclass
class ProposalConfig:
    client_first_name: str
    client_last_name: str
    client_email: str
    client_company: str
    project_title: str
    tokens: list[dict]

def validate_input(data: Dict[str, Any]) -> ProposalConfig:
    """Validates the input JSON and returns a configuration object."""
    try:
        client = data.get("client", {})
        project = data.get("project", {})
        
        # Basic validation
        if not client.get("email"):
            raise ValueError("Client email is required")
        
        # Extract tokens from the flat list provided in the input or construct them
        # The input format specified in the prompt implies the input JSON has 'tokens' 
        # OR we need to construct them from the 'project' and 'client' fields.
        # The prompt's "Request Body Structure" shows how to map them.
        # However, the prompt's "Input Format" is what we receive. 
        # So we must map Input -> Request Body.
        
        tokens = [
            {"name": "Client.Company", "value": client.get("company", "")},
            {"name": "Personalization.Project.Title", "value": project.get("title", "")},
            {"name": "MonthOneInvestment", "value": str(project.get("monthOneInvestment", ""))},
            {"name": "MonthTwoInvestment", "value": str(project.get("monthTwoInvestment", ""))},
            {"name": "MonthThreeInvestment", "value": str(project.get("monthThreeInvestment", ""))},
        ]
        
        # Add dynamic tokens from the input if they exist (generated by LLM)
        # The prompt says the LLM generates "Expanded problem 01", etc.
        # We expect the input JSON to potentially contain these expanded values 
        # OR we expect the LLM to have already put them into the structure.
        # Let's look at the "Input Format" again.
        # It has "problems": { "problem01": ... }
        # The prompt says "Content Generation Rules... Transform brief problem statements into 1-2 strategic paragraphs".
        # So the LLM *should* have done this transformation BEFORE calling this script if we follow the "LLM endpoint" idea.
        # BUT, the user said: "instantiate this workflow as a Python script... use yourself as an LLM endpoint... and then feed those variables into said Python script".
        # This implies the Python script receives the *final* values.
        # Let's assume the input `data` matches the "Input Format" but with *expanded* content if the LLM did its job, 
        # OR the script receives the *already formatted* tokens?
        # The prompt "Input Format" shows "string - first problem area".
        # The "Request Body Structure" shows "tokens": [ { "name": "Personalization.Project.Problem01", "value": "[Expanded problem 01]" } ]
        # So the mapping happens here.
        
        # Let's map the 'problems' and 'benefits' from the input to the tokens.
        problems = project.get("problems", {})
        benefits = project.get("benefits", {})
        
        tokens.append({"name": "Personalization.Project.Problem01", "value": problems.get("problem01", "")})
        tokens.append({"name": "Personalization.Project.Problem02", "value": problems.get("problem02", "")})
        tokens.append({"name": "Personalization.Project.Problem03", "value": problems.get("problem03", "")})
        tokens.append({"name": "Personalization.Project.Problem04", "value": problems.get("problem04", "")})
        
        tokens.append({"name": "Personalization.Project.Benefit.01", "value": benefits.get("benefit01", "")})
        tokens.append({"name": "Personalization.Project.Benefit.02", "value": benefits.get("benefit02", "")})
        tokens.append({"name": "Personalization.Project.Benefit.03", "value": benefits.get("benefit03", "")})
        tokens.append({"name": "Personalization.Project.Benefit.04", "value": benefits.get("benefit04", "")})

        # Add other generated fields if passed in top-level or project
        # The prompt "Input Format" doesn't explicitly show 'generated_footer' etc,
        # but the "Request Body" needs them.
        # I will check if they are in `data` root or `project`.
        # Let's assume they might be passed in `data` root for simplicity as "generated".
        generated = data.get("generated", {})

        # Generate slide footer if not provided: "Client Name x LeftClick"
        slide_footer = generated.get("slideFooter", "")
        if not slide_footer:
            client_company = client.get("company", "Client")
            slide_footer = f"{client_company} x LeftClick"

        tokens.append({"name": "Slide.Footer", "value": slide_footer})
        tokens.append({"name": "Contract.FooterSlug", "value": generated.get("contractFooterSlug", "")})
        tokens.append({"name": "Document.CreatedDate", "value": generated.get("createdDate", "")})

        return ProposalConfig(
            client_first_name=client.get("firstName", ""),
            client_last_name=client.get("lastName", ""),
            client_email=client.get("email", ""),
            client_company=client.get("company", ""),
            project_title=project.get("title", ""),
            tokens=tokens
        )
    except Exception as e:
        raise ValueError(f"Invalid input format: {str(e)}")

def create_document(config: ProposalConfig) -> Dict[str, Any]:
    if not API_KEY:
        raise ValueError("PANDADOC_API_KEY not found in environment variables")

    headers = {
        "Authorization": f"API-Key {API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "name": config.project_title,
        "template_uuid": TEMPLATE_UUID,
        "recipients": [
            {
                "email": config.client_email,
                "firstName": config.client_first_name,
                "lastName": config.client_last_name,
                "role": "Client"
            }
        ],
        "tokens": config.tokens
    }

    # Retry logic
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.post(API_URL, headers=headers, json=payload, timeout=10)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            if attempt == max_retries - 1:
                raise Exception(f"Failed to create document after {max_retries} attempts: {str(e)}")
            time.sleep(2 ** attempt) # Exponential backoff

def main():
    if len(sys.argv) > 1:
        # Read from file if argument provided
        try:
            with open(sys.argv[1], 'r') as f:
                data = json.load(f)
        except Exception as e:
            print(json.dumps({"success": False, "error": {"message": f"Failed to read input file: {str(e)}"}}, indent=2))
            sys.exit(1)
    else:
        # Read from stdin
        try:
            input_str = sys.stdin.read()
            if not input_str.strip():
                # For testing/debugging, allow empty input to just print usage or mock
                print(json.dumps({"success": False, "error": {"message": "No input provided"}}, indent=2))
                sys.exit(1)
            data = json.loads(input_str)
        except Exception as e:
            print(json.dumps({"success": False, "error": {"message": f"Failed to parse JSON input: {str(e)}"}}, indent=2))
            sys.exit(1)

    try:
        config = validate_input(data)
        result = create_document(config)
        
        # Construct success response
        doc_id = result.get("id")
        response = {
            "success": True,
            "documentId": doc_id,
            "documentUrl": f"https://app.pandadoc.com/s/{doc_id}" if doc_id else None, # Note: The prompt asked for /s/ link in one place and /a/ in another. /s/ is usually shared, /a/ is app. I'll provide /a/ for internal use as requested in Overview.
            # Actually Overview says: "present an internal PandaDoc link (https://app.pandadoc.com/a/#/documents/[document_id])"
            # But Success Response format says: "https://app.pandadoc.com/s/abc123def456"
            # I will provide the internal app link as it is more useful for the user to edit.
            "internalLink": f"https://app.pandadoc.com/a/#/documents/{doc_id}" if doc_id else None,
            "documentName": config.project_title,
            "recipientEmail": config.client_email,
            "status": result.get("status")
        }
        print(json.dumps(response, indent=2))
        
    except Exception as e:
        print(json.dumps({
            "success": False, 
            "error": {
                "message": str(e)
            }
        }, indent=2))
        sys.exit(1)

if __name__ == "__main__":
    main()
