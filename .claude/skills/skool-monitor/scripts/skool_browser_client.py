#!/usr/bin/env python3
"""
Skool browser-based client that uses Playwright to auto-generate AWS WAF tokens.
This solves the single-use token problem by maintaining a real browser session.
"""

import os
import sys
import json
import time
from dotenv import load_dotenv
from playwright.sync_api import sync_playwright, Browser, BrowserContext, Page

load_dotenv()


def format_for_skool(text: str) -> str:
    """Convert plain text to Skool's TipTap/ProseMirror HTML format."""
    paragraphs = text.split('\n\n')  # Split on blank lines
    html_parts = []
    for p in paragraphs:
        p = p.replace('\n', '<br>')  # Single newlines become <br>
        html_parts.append(f'<p>{p}</p>')
    # Join paragraphs with blank line marker
    return '<p><br class="ProseMirror-trailingBreak"></p>'.join(html_parts)


class SkoolBrowserClient:
    """
    Skool client that uses a real browser to bypass WAF token limitations.
    Maintains a persistent browser session and extracts fresh tokens on demand.
    """

    def __init__(self, auth_token=None, client_id=None, headless=True):
        self.base_url = "https://www.skool.com"
        self.api_base_url = "https://api2.skool.com"

        self.auth_token = auth_token or os.getenv("SKOOL_AUTH_TOKEN")
        self.client_id = client_id or os.getenv("SKOOL_CLIENT_ID")

        if not self.auth_token:
            raise ValueError("SKOOL_AUTH_TOKEN not found in environment")

        self.headless = headless
        self.playwright = None
        self.browser = None
        self.context = None
        self.page = None

        self._start_browser()

    def _start_browser(self):
        """Start Playwright browser with authentication cookies."""
        print("Starting browser session...")

        self.playwright = sync_playwright().start()
        self.browser = self.playwright.chromium.launch(headless=self.headless)

        # Create context with cookies
        self.context = self.browser.new_context(
            user_agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36"
        )

        # Add authentication cookies
        self.context.add_cookies([
            {
                'name': 'auth_token',
                'value': self.auth_token,
                'domain': '.skool.com',
                'path': '/'
            },
            {
                'name': 'client_id',
                'value': self.client_id,
                'domain': '.skool.com',
                'path': '/'
            }
        ])

        self.page = self.context.new_page()

        # Navigate to Skool to establish session
        print("Loading Skool...")
        self.page.goto(f"{self.base_url}/makerschool", wait_until="domcontentloaded")
        time.sleep(2)  # Wait for any background JS to execute

        print("✓ Browser session established")

    def _get_fresh_waf_token(self):
        """
        Get a fresh AWS WAF token from the browser cookies.
        This is automatically generated by Skool's JavaScript.
        """
        cookies = self.context.cookies()
        for cookie in cookies:
            if cookie['name'] == 'aws-waf-token':
                return cookie['value']

        # If no token yet, trigger it by navigating
        print("No WAF token found, triggering generation...")
        self.page.reload(wait_until="domcontentloaded")
        time.sleep(2)

        cookies = self.context.cookies()
        for cookie in cookies:
            if cookie['name'] == 'aws-waf-token':
                return cookie['value']

        raise Exception("Could not obtain AWS WAF token from browser")

    def _make_api_request(self, method, endpoint, json_data=None, params=None):
        """
        Make an API request using fresh WAF token from browser.
        """
        waf_token = self._get_fresh_waf_token()

        # Build the full URL
        url = f"{self.api_base_url}{endpoint}"
        if params:
            query_string = '&'.join(f"{k}={v}" for k, v in params.items())
            url = f"{url}?{query_string}"

        # Make request using Playwright's request context
        response = self.context.request.fetch(
            url,
            method=method,
            headers={
                'accept': '*/*',
                'content-type': 'application/json',
                'origin': 'https://www.skool.com',
                'referer': 'https://www.skool.com/',
                'x-aws-waf-token': waf_token
            },
            data=json.dumps(json_data) if json_data else None
        )

        if response.status == 403:
            # Token might have been used, try once more with fresh token
            print("Got 403, retrying with fresh token...")
            time.sleep(1)
            waf_token = self._get_fresh_waf_token()

            response = self.context.request.fetch(
                url,
                method=method,
                headers={
                    'accept': '*/*',
                    'content-type': 'application/json',
                    'origin': 'https://www.skool.com',
                    'referer': 'https://www.skool.com/',
                    'x-aws-waf-token': waf_token
                },
                data=json.dumps(json_data) if json_data else None
            )

        if not response.ok:
            raise Exception(f"API request failed: {response.status} - {response.text()}")

        # Some endpoints return empty body on success
        try:
            return response.json()
        except Exception:
            return {"status": response.status, "success": True}

    def get_group_id(self, community_slug):
        """Extract group_id from a community page."""
        url = f"{self.base_url}/{community_slug}"
        self.page.goto(url, wait_until="domcontentloaded")

        # Extract from __NEXT_DATA__
        next_data = self.page.evaluate("""
            () => {
                const script = document.getElementById('__NEXT_DATA__');
                return script ? JSON.parse(script.textContent) : null;
            }
        """)

        if not next_data:
            raise Exception("Could not find __NEXT_DATA__")

        group = next_data.get('props', {}).get('pageProps', {}).get('currentGroup', {})
        group_id = group.get('id')

        if not group_id:
            raise Exception("Could not extract group_id")

        return group_id

    def create_post(self, group_id, title, content, labels=None, follow=True):
        """Create a new post in a community."""
        payload = {
            "post_type": "generic",
            "group_id": group_id,
            "metadata": {
                "title": title,
                "content": content,
                "attachments": "",
                "labels": labels or "",
                "action": 0,
                "video_ids": ""
            }
        }

        params = {'follow': 'true' if follow else 'false'}
        return self._make_api_request('POST', '/posts', json_data=payload, params=params)

    def reply_to_post(self, group_id, post_id, content, follow=False):
        """Reply to an existing post (create a comment)."""
        payload = {
            "post_type": "comment",
            "group_id": group_id,
            "root_id": post_id,
            "parent_id": post_id,
            "metadata": {
                "title": "",
                "content": content,
                "attachments": "",
                "action": 0,
                "video_ids": ""
            }
        }

        params = {'follow': 'true' if follow else 'false'}
        return self._make_api_request('POST', '/posts', json_data=payload, params=params)

    def like_post(self, post_id):
        """Like a post or comment."""
        payload = {"old": "", "new": "up"}
        return self._make_api_request('PUT', f'/posts/{post_id}/vote', json_data=payload)

    def unlike_post(self, post_id):
        """Remove like from a post or comment."""
        payload = {"old": "up", "new": ""}
        return self._make_api_request('PUT', f'/posts/{post_id}/vote', json_data=payload)

    def close(self):
        """Clean up browser resources."""
        if self.page:
            self.page.close()
        if self.context:
            self.context.close()
        if self.browser:
            self.browser.close()
        if self.playwright:
            self.playwright.stop()
        print("Browser session closed")

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


def main():
    import argparse
    parser = argparse.ArgumentParser(description="Skool browser client (auto WAF tokens)")
    parser.add_argument("command",
                       choices=['create', 'reply', 'like', 'unlike', 'group-id'],
                       help="Command to run")
    parser.add_argument("--community", default="makerschool", help="Community slug")
    parser.add_argument("--title", help="Post title (for create)")
    parser.add_argument("--content", help="Post/comment content")
    parser.add_argument("--post-id", help="Post ID (for reply/like/unlike)")
    parser.add_argument("--group-id", help="Group ID (for create/reply)")
    parser.add_argument("--labels", help="Label ID for post category")
    parser.add_argument("--headless", action="store_true", default=True, help="Run browser in headless mode")
    parser.add_argument("--visible", action="store_true", help="Show browser window (debug)")

    args = parser.parse_args()

    try:
        headless = args.headless and not args.visible

        with SkoolBrowserClient(headless=headless) as client:
            if args.command == 'group-id':
                print(f"Getting group_id for {args.community}...")
                group_id = client.get_group_id(args.community)
                print(f"Group ID: {group_id}")

            elif args.command == 'create':
                if not args.title or not args.content:
                    print("Error: --title and --content are required for create")
                    sys.exit(1)

                if not args.group_id:
                    print(f"Group ID not provided, fetching from {args.community}...")
                    group_id = client.get_group_id(args.community)
                else:
                    group_id = args.group_id

                print(f"Creating post in {args.community}...")
                result = client.create_post(group_id, args.title, args.content, labels=args.labels)
                print("✓ Post created successfully!")
                print(json.dumps(result, indent=2))

            elif args.command == 'reply':
                if not args.content or not args.post_id:
                    print("Error: --content and --post-id are required for reply")
                    sys.exit(1)

                if not args.group_id:
                    print(f"Group ID not provided, fetching from {args.community}...")
                    group_id = client.get_group_id(args.community)
                else:
                    group_id = args.group_id

                print(f"Replying to post {args.post_id}...")
                result = client.reply_to_post(group_id, args.post_id, args.content)
                print("✓ Reply posted successfully!")
                print(json.dumps(result, indent=2))

            elif args.command == 'like':
                if not args.post_id:
                    print("Error: --post-id is required for like")
                    sys.exit(1)

                print(f"Liking post {args.post_id}...")
                result = client.like_post(args.post_id)
                print("✓ Post liked successfully!")
                print(json.dumps(result, indent=2))

            elif args.command == 'unlike':
                if not args.post_id:
                    print("Error: --post-id is required for unlike")
                    sys.exit(1)

                print(f"Unliking post {args.post_id}...")
                result = client.unlike_post(args.post_id)
                print("✓ Post unliked successfully!")
                print(json.dumps(result, indent=2))

    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
